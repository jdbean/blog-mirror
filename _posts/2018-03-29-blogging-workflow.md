---
layout: post
title: "An Automated Testing and Deployment Workflow for Jekyll"
date:  2018-03-19
description: > #(optional)
    A description of my custom workflow for building, testing,
    and deploying this Jekyll blog into production.
img: #(optional)
tags: [Blogging, Workflow, GitLab, Jekyll, Docker, Rsync, SSH]  #(optional)
---

When I decided to start this blog the first thing I need to do was to determine what tools or platforms I wanted to use to blog with.
After asking around and doing some research I determined that popular hosted choices that might have suited me included WordPress, SquareSpace, Medium, GitHub Pages, and Ghost.
<!-- insert links for blogging platforms -->
While I'm sure any of these tools would work well I wanted to find a solution which provided greater flexibility and an opportunity to do some deeper learning about software development, testing, and deployment.

After laying out my requirments and investigating some options such as setting up my own WordPress or Ghost install. However, I ultimately ended up resolving to set up a blogging workflow using: Jekyll, Git, GitLab, Docker, GitLab Runner, Rsync, SSH, and a Web server.
<!-- insert links for tools -->
I could write a post about each of these tools individually but I want to focus this post on a high-level overview of how I integrated each component into a blogging workflow with a number of advantages over the alternatives I considered.

# Summary / Benefits

The toolchain I employ gives me the following benefits over some/all of the alternatives I considered:

  * Complete control over the entire blogging process.
  * An opportunity to learn about development and web technologies.
  * A reproducible and consistent build environment.
  * My site is lean and static.
  * The ability to test my site and deploy it for review before deploying in to production.
  * Based entirely in plain text which allows me to utilize familiar development tools such as version control and editors.
  * The ability to write from any machine without the need to set up a build environment.
  * A centralized and automated deployment process.
  * The satisfaction of "rolling-my-own".

# Jekyll

Jekyll is probably the best known among the array of static site generators that have become popular over the last decade or so.
Jekyll's popularity is, at least in part, due to its adoption by GitHub as the
backend for its [GitHub Pages](https://pages.github.com) feature.
Jekyll is written in Ruby and outputs a static website site from YAML configuration files, html templates, and markdown formatted posts, along with other assets such as javascript, fonts, and images.
Because Jekyll sites are not dynamically generated by a server-side program they are generally perfomant and easy to deploy.

One can easily generate Jekyll sites on a local workstation by running the following in a Jekyll project directory:

``` console
$ jekyll new
$ jekyll build
```
<!-- Why is the install in bundle install green? -->

Running this command will generate a `_site` directory which contains a fully assembled website.
For local development purposes Jekyll even includes the extremely useful

``` terminal
$ jekyll serve
```

This command serves the site locally so it can be accessed in the browser at `http://127.0.0.1:4000/`. Adding the `--watch` flag watches the project's directory and rebuilds the site each time a file is updated.

I selected  one of the many beautiful open source Jekyll themes, made a few tweaks to the CSS and HTML to suit my preferences and configured my new site.
Along with a web server to upload the site to, I had a great blogging platform all set up and ready to go in no time.

# Git / GitLab

Once I had the fundamentals of my site taken care of I started thinking about what I could do to make my blog and my blogging workflow as professional and flexible as possible.
It was an obvious next step to manage my blogging workflow through a Git repository in order to gain the benefits afforded by a VCS system.
In order to be able to work on the blog from multiple machines I decided to upload by local repository to a Git server.

While something like GitHub would have worked well, I was already running a self-hosted GitLab server in my home lab which was a perfect fit for the job.
GitLab is a really fantastic company which, in addition to a hosted service at [GitLab.com](https://gitlab.com) also offers enterprise and personal versions of its software for users to deploy on their own.
Along with simply serving as an always-on host for my Git repository GitLab has a ton of project management features that are useful for organizing my blogging.

# CI/CD

My favorite feature of GitLab is its integrated continuous integration / continuous delivery feature0

``` yml
image: jekyll/builder

variables:
  JEKYLL_ENV: production

cache:
  paths:
   - vendor/
   - var/lib/apt/

test:
  stage: build
  before_script:
         - bundle install --path vendor
  script:
  - bundle exec jekyll build -d staging_site
  artifacts:
    paths:
    - staging_site
  only:
  - master
  - production

deploy:
  stage: deploy

  before_script:

  ## Install ssh-agent if not already installed, it is required by Docker.
  ## (change apt-get to yum if you use an RPM-based image)
  - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'

  ## Install rysnc if not already installed
  - 'which rsync || ( apt-get update -y && apt-get install rsync -y )'

  ## Run ssh-agent (inside the build environment)
  - eval $(ssh-agent -s)

  ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
  ## We're using tr to fix line endings which makes ed25519 keys work
  ## without extra base64 encoding.
  - echo "$SSH_KEY" | tr -d '\r' | ssh-add - > /dev/null

  ## Create the SSH directory and give it the right permissions
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh

  ## Add remote pub keys (SSH_KNOWN_HOSTS) to known_hosts
  - echo "$SSH_KNOWN_HOSTS" > ~/.ssh/known_hosts
  - chmod 644 ~/.ssh/known_hosts

  script:

  ## Deploy the staging directory to the staging server
  - rsync -avz --delete -e ssh --progress -r staging_site/ "$SITE_USER_AND_ADDRESS"

  only:
  - production
```
